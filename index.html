<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SafeRoute: Family-First Disaster Hub</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load QR Code Generator -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <style>
        /* Import Inter font (Tailwind default) - kept for explicit confirmation */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f0f4f8; }
        
        /* Custom Styles for Tabs and Cards */
        .tab-button { 
            padding: 0.75rem 0.5rem; 
            text-align: center; 
            color: #4b5563; 
            font-weight: 600; 
            border-bottom: 3px solid transparent; 
            transition: all 0.2s;
            touch-action: manipulation; /* Improves touch responsiveness */
        }
        .tab-button.active { 
            border-color: #4f46e5; 
            color: #4f46e5; 
            background: #eef2ff; 
        }
        .card { 
            background: white;
            border-radius: 0.75rem; 
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.05); 
            border: 1px solid #e2e8f0;
        }
        .pulse-animation { animation: pulse 2s cubic-bezier(0.4,0,0.6,1) infinite; }
        @keyframes pulse { 0%,100%{opacity:1}50%{opacity:.4} }

        /* Chat styles for clear user/ai distinction */
        .chat-window .user-message { 
            background-color: #3b82f6; /* Blue-600 */
            color: white; 
            padding: 0.75rem; 
            border-radius: 0.75rem 0.75rem 0 0.75rem; 
            align-self: flex-end; 
            max-width: 85%; 
            margin-left: auto;
            word-wrap: break-word;
        }
        .chat-window .ai-message { 
            background-color: #ffffff; 
            color: #1f2937; 
            padding: 0.75rem; 
            border-radius: 0.75rem 0.75rem 0.75rem 0; 
            border: 1px solid #e5e7eb; 
            align-self: flex-start; 
            max-width: 85%; 
            margin-right: auto;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Configuration for JamAI Base (CRITICAL FIX) -->
    <script>
        // NOTE: REPLACE THESE PLACEHOLDERS with your actual JamAI values
        // If these are incorrect or incomplete, the decoding/routing WILL FAIL.

        // 1. CRITICAL: JamAI Personal Access Token (PAT)
        window.JAMAI_PAT = "mypat"; 

        // 2. CRITICAL: JamAI Project ID
        window.JAMAI_PROJECT_ID = "myid"; 

        // 3. CRITICAL FIX: JamAI LLM Inference API URL
        // Must point to the endpoint that accepts the {contents, systemInstruction} payload.
        // Example uses a common format:
        window.JAMAI_API_URL = 'https://api.jamaibase.com/v1/generate/content'; 

        // 4. RECOMMENDED: JamAI Table API URL for Add Rows
        // Used for logging and SOP upload (emergency_routing table).
        window.JAMAI_TABLE_API_URL = 'https://api.jamaibase.com/api/v2/gen_tables/action/rows/add';


        // --- FORCING GUEST MODE ---
        window.isGuest = true;
        const GUEST_ID_KEY = 'smartpps_guest_id';
        if (!localStorage.getItem(GUEST_ID_KEY)) localStorage.setItem(GUEST_ID_KEY, 'guest-' + crypto.randomUUID());
        window.userId = localStorage.getItem(GUEST_ID_KEY);
        window.ENABLE_SUPABASE = false; // Disable any Supabase references

        // Simple storage helper functions 
        window.saveFamilyData = async (data) => {
            try {
                const key = `smartpps_profile_${window.userId}`;
                const existing = JSON.parse(localStorage.getItem(key) || '{}');
                const merged = Object.assign({}, existing, data);
                merged.updated_at = new Date().toISOString();
                localStorage.setItem(key, JSON.stringify(merged));
                window.familyData = merged;
                if (window.updateUIAfterDataLoad) window.updateUIAfterDataLoad(merged);
                return true;
            } catch (e) { console.error('saveFamilyData error', e); return false; }
        };

        window.loadFamilyData = async () => {
            try {
                const key = `smartpps_profile_${window.userId}`;
                const stored = localStorage.getItem(key);
                if (stored) {
                    window.familyData = JSON.parse(stored);
                    if (window.updateUIAfterDataLoad) window.updateUIAfterDataLoad(window.familyData);
                    return window.familyData;
                }
                window.familyData = {};
                return window.familyData;
            } catch (e) { console.error('loadFamilyData error', e); window.familyData = {}; return window.familyData; }
        };
    </script>

    <!-- Header -->
    <header class="bg-indigo-700 text-white p-4 shadow-xl">
        <h1 class="text-2xl font-extrabold tracking-tight">SafeRoute: Disaster Hub</h1>
        <p id="user-id-display" class="text-xs opacity-70 mt-1">Guest ID: <span id="uid-span"></span></p>
    </header>

    <!-- Guest Mode Banner -->
    <div id="guest-info" class="p-3 bg-yellow-50 border-b border-yellow-400">
        <div class="max-w-4xl mx-auto text-sm text-yellow-800 font-medium text-center md:text-left">
            ‚ö†Ô∏è **Guest Mode:** All data is saved locally in your browser.
        </div>
        <div class="max-w-4xl mx-auto text-sm text-yellow-800 font-medium text-center md:text-right mt-2">
            <button id="upload-sop-button" class="ml-2 inline-flex items-center px-3 py-1.5 border border-transparent text-xs leading-4 font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700" onclick="runSOPTest()">Upload SOP to JamAI (Test)</button>
            <span id="upload-sop-status" class="ml-3 text-xs font-medium text-gray-700"></span>
        </div>
    </div>
    
    <!-- Tab Navigation (Responsive: 2-col on mobile, 4-col on tablet/desktop) -->
    <nav class="bg-white shadow-lg sticky top-0 z-10">
        <div class="grid grid-cols-2 md:grid-cols-4 border-b border-gray-200">
            <button class="tab-button active" onclick="showTab('situation')" id="tab-situation">1. Situation</button>
            <button class="tab-button" onclick="showTab('routing')" id="tab-routing">2. Intelligent Route</button>
            <button class="tab-button" onclick="showTab('qr-passport')" id="tab-qr-passport">3. QR Passport</button>
            <button class="tab-button" onclick="showTab('rumour-killer')" id="tab-rumour-killer">4. Rumour Killer</button>
        </div>
    </nav>

    <!-- Main Content Area -->
    <main class="flex-1 p-4 overflow-y-auto max-w-4xl mx-auto">

        <!-- Tab 1: Your Situation (Location & Semantic Input) -->
        <section id="situation" class="tab-content space-y-6">
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2">1. Situation & Needs Assessment</h2>
            
            <p class="text-base text-gray-600 font-semibold bg-blue-50 p-4 rounded-lg border-l-4 border-blue-500">
                **Phase 1:** Confirm your location and clearly describe your family's needs for safe routing.
            </p>
            
            <!-- Step 1: Location & Status -->
            <div class="card p-5">
                <h3 class="text-xl font-extrabold text-indigo-700 mb-3 flex items-center gap-2">üìç Confirm Location</h3>
                
                <div id="location-status-container">
                    <p id="current-location-display" class="text-base text-gray-700 font-semibold pulse-animation mb-4"></p>
                    
                    <!-- Dynamic Manual Input Form (shown if GPS/IP fails) -->
                    <form id="manual-location-form" class="mt-4 border-t pt-4 hidden space-y-3">
                        <p class="text-sm font-bold text-red-600">‚ùå Auto-detection failed. Enter your location manually.</p>
                        <input type="text" id="manual-city-input" required placeholder="Enter City/Suburb (e.g., Segamat, Johor)" class="w-full rounded-lg border-gray-300 shadow-sm p-3 border">
                        <button type="submit" class="w-full py-3 px-4 rounded-lg text-white font-bold bg-red-600 hover:bg-red-700 transition">Confirm Location</button>
                    </form>
                </div>
            </div>

            <!-- Step 2: Semantic Intent Input -->
            <div class="card p-5">
                <h3 class="text-xl font-extrabold text-gray-800 mb-3">Describe Needs (Semantic Input)</h3>
                <p class="text-sm text-gray-600 mb-4">Input your family's situation to decode specific needs (vulnerabilities).</p>
                <p class="text-xs text-indigo-500 italic mb-3 p-2 bg-indigo-50 rounded-lg">Example: <strong>"4 people, one is elderly who can't walk, and we have a pet cat."</strong></p>

                <form id="semantic-form" class="space-y-4">
                    <textarea id="semantic-input" required rows="3" placeholder="Describe your family's situation and vulnerabilities here..." class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm p-3 border focus:ring-indigo-500 focus:border-indigo-500"></textarea>

                    <button type="submit" id="semantic-submit-button" class="w-full py-3 px-4 rounded-lg shadow-lg text-base font-bold text-white bg-indigo-600 hover:bg-indigo-700 transition">
                        ‚ú® Get Safe Route & Local Status
                    </button>
                </form>
            </div>
        </section>

        <!-- Tab 2: Intelligent Routing -->
        <section id="routing" class="tab-content hidden space-y-6">
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2">2. Intelligent Routing Analysis</h2>
            
            <!-- Local Status / Weather Results -->
            <div id="local-status-results-routing" class="card p-5 border-l-4 transition duration-300">
                <h3 class="text-xl font-extrabold text-red-700 mb-3 flex items-center">üö® Real-Time Status & Weather</h3>
                <div id="status-content">
                    <p class="text-sm text-gray-500">Awaiting status check from JamAI Base...</p>
                </div>
            </div>

<!-- Decoded Input -->
<div class="card p-5">
    <p class="text-lg font-extrabold text-indigo-700 mb-2">AI Decoded Needs:</p>
    <div id="current-vulnerabilities" class="text-gray-500 italic text-base mb-4">
        Awaiting JamAI decoding...
    </div>
    <p class="text-xs text-gray-500">Calculation based on location: 
        <span id="routing-coords" class="font-mono text-gray-700">N/A</span>
    </p>
</div>

<!-- Results Section -->
<div id="routing-results" class="space-y-4">
    <div id="analysis-display" class="card p-5 bg-white border-2 border-indigo-400 hidden">
        <!-- Analysis Text will be inserted here -->
    </div>

    <div id="best-match-display" class="card p-5 text-center hidden bg-green-50 border-2 border-green-400">
        <!-- Selected PPS will be inserted here -->
    </div>

    <div class="flex justify-end">
        <button id="save-routing-button" class="py-2 px-3 text-xs rounded-md bg-indigo-600 text-white hover:bg-indigo-700" onclick="saveRoutingToJamAI()">
            Save routing to JamAI table (Test)
        </button>
        <span id="save-routing-status" class="ml-3 text-xs text-gray-600"></span>
    </div>

    <p id="jamai-citation" class="text-xs text-gray-500 pt-4 border-t hidden">
        AI Reasoning provided by JamAI Base (with PPS Knowledge RAG).
    </p>
</div>

        </section>

        <!-- Tab 3: QR Passport -->
        <section id="qr-passport" class="tab-content hidden space-y-6">
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2">3. JKM Passport Creation</h2>
            <p class="text-base text-gray-600">Complete the details below to generate your **Zero-Typing QR Passport** for rapid registration.</p>

            <div id="save-status" class="p-3 text-sm rounded-lg font-medium hidden"></div>

            <!-- JKM Passport Form -->
            <form id="family-form" class="space-y-4 card p-5">
                <label class="block text-sm font-semibold text-gray-700">Head of Family Name</label>
                <input type="text" id="headName" required class="mt-1 block w-full rounded-lg p-3 border">
                
                <label class="block text-sm font-semibold text-gray-700">IC Number (12 digits)</label>
                <input type="text" id="icNumber" required pattern="\d{12}" title="12 digits without dashes" class="mt-1 block w-full rounded-lg p-3 border">
                
                <label class="block text-sm font-semibold text-gray-700">Home Address</label>
                <textarea id="address" required rows="2" class="mt-1 block w-full rounded-lg p-3 border"></textarea>
                
                <label class="block text-sm font-semibold text-gray-700">Total Family Size</label>
                <input type="number" id="familySize" required min="1" value="1" class="mt-1 block w-full rounded-lg p-3 border">
                
                <div class="mt-4 p-4 bg-blue-50 rounded-lg border border-blue-200">
                    <p class="text-sm font-bold text-gray-800 mb-1">Stored Needs:</p>
                    <div id="vulnerability-list-display" class="text-sm text-gray-700">None saved.</div>
                </div>

                <button type="submit" class="w-full py-3 px-4 rounded-lg shadow-md text-base font-bold text-white bg-indigo-600 hover:bg-indigo-700 transition">
                    Save Details & Generate QR Passport
                </button>
            </form>

            <!-- QR Code Output & Wallet Buttons -->
            <div id="qr-container" class="flex flex-col items-center justify-center card p-6 space-y-4">
                <div id="qrcode-display" class="p-4 border-4 border-indigo-600 rounded-xl bg-white shadow-2xl">
                    <canvas id="qr-canvas" class="w-64 h-64 md:w-80 md:h-80"></canvas>
                </div>
                <p id="qr-status" class="text-center text-red-500 font-bold">No family data saved yet.</p>
                <div class="flex flex-col md:flex-row gap-2 w-full justify-center">
                    <button id="copy-payload-button" class="py-2 px-4 border rounded-lg text-sm font-medium bg-gray-100 hover:bg-gray-200 transition hidden" onclick="copyJKMPayload()">
                        Copy JKM Payload (Raw Text)
                    </button>
                    <!-- PKPASS Button: Simulates sending an email with the server-generated pass -->
                    <button id="email-pkpass-button" class="py-2 px-4 rounded-lg text-sm font-medium bg-green-600 text-white hover:bg-green-700 transition hidden" disabled>
                        ‚úâÔ∏è Email Wallet Pass (.pkpass)
                    </button>
                </div>
                <p id="pkpass-status" class="text-xs text-gray-500 mt-2 text-center">
                    (Save details first to enable Wallet export)
                </p>
            </div>
            <div class="mt-6 text-sm p-4 bg-gray-100 rounded-lg border border-gray-300">
                <p class="font-semibold text-gray-700">JKM Schema Preview (Raw Payload):</p>
                <code id="jkm-payload-preview" class="block whitespace-pre-wrap break-words text-gray-600 mt-2 text-xs font-mono">Awaiting data...</code>
            </div>
        </section>
        
        <!-- Tab 4: Rumour Killer (Grounded Q&A) -->
        <section id="rumour-killer" class="tab-content hidden space-y-4">
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2">4. Rumour Killer (Grounded Q&A)</h2>
            <p class="text-base text-gray-600">Verify information and get official safety guidance using real-time search.</p>

            <div id="chat-window" class="chat-window card p-4 h-96 overflow-y-auto flex flex-col space-y-3">
                <div class="ai-message">
                    <p class="text-sm font-medium">Welcome! Ask me anything about current disaster status or safety procedures.</p>
                </div>
            </div>

            <form id="rumour-form" class="flex space-x-2">
                <input type="text" id="rumour-input" required placeholder="Type your question here..." class="flex-1 rounded-lg border-gray-300 shadow-sm p-3 border focus:ring-indigo-500 focus:border-indigo-500">
                <button type="submit" id="rumour-submit-button" class="shrink-0 py-3 px-4 rounded-lg text-white font-bold bg-indigo-600 hover:bg-indigo-700 transition shadow-md">
                    Ask ‚ú®
                </button>
            </form>
        </section>
    </main>

    <!-- JavaScript Logic -->
    <script>
        // JamAI Base Configuration (loaded from window properties)
        const JAMAI_PAT = window.JAMAI_PAT || "";
        const JAMAI_PROJECT_ID = window.JAMAI_PROJECT_ID || "";
        const JAMAI_API_URL = window.JAMAI_API_URL || null;

        // API setup
        const IP2LOCATION_KEY = "D2D17B84A589ED1060A87E4DD69AC1A9";
        const IP2LOCATION_URL_BASE = `https://api.ip2location.io/?key=${IP2LOCATION_KEY}`;
        const API_KEY = ""; 
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        // CRITICAL: LLM_API_URL will now correctly use JAMAI_API_URL if it is set.
        const LLM_API_URL = JAMAI_API_URL || GEMINI_API_URL;
        
        let familyData = window.familyData || {};
        let userLocation = { city: 'Unknown City', region: 'Malaysia', lat: 3.140853, lon: 101.693240, source: 'Default' };
        
        document.getElementById('uid-span').textContent = window.userId.substring(0, 8); // Abbreviated ID for aesthetics


        // --- Location Functions ---
        function updateLocationUI() {
            const display = document.getElementById('current-location-display');
            const manualForm = document.getElementById('manual-location-form');
            const routingCoords = document.getElementById('routing-coords');
            
            let statusText = '';
            
            if (userLocation.source === 'GPS') {
                statusText = `‚úÖ <b>GPS Detected:</b> ${userLocation.city}, ${userLocation.region} (${userLocation.lat.toFixed(4)}, ${userLocation.lon.toFixed(4)})`;
                manualForm.classList.add('hidden');
                display.classList.remove('pulse-animation');
            } else if (userLocation.source === 'IP Fallback') {
                statusText = `‚ö†Ô∏è <b>IP Detected (Fallback):</b> ${userLocation.city}, ${userLocation.region} (${userLocation.lat.toFixed(4)}, ${userLocation.lon.toFixed(4)})`;
                manualForm.classList.add('hidden');
                display.classList.remove('pulse-animation');
            } else if (userLocation.source === 'Manual') {
                statusText = `üìç <b>Manual Location:</b> ${userLocation.city}, ${userLocation.region}`;
                manualForm.classList.add('hidden');
                display.classList.remove('pulse-animation');
            } else { // Manual Input Required
                statusText = `‚ùå <b>Location Required:</b> Automatic detection failed. Please confirm below.`;
                manualForm.classList.remove('hidden');
                display.classList.add('pulse-animation');
            }

            display.innerHTML = statusText;
            routingCoords.textContent = `${userLocation.lat.toFixed(4)}, ${userLocation.lon.toFixed(4)} (Source: ${userLocation.source})`;
        }

        async function getGPSLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) return reject("Geolocation not supported.");
                const options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 };

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        userLocation.lat = position.coords.latitude;
                        userLocation.lon = position.coords.longitude;
                        userLocation.city = 'Your GPS Area';
                        userLocation.region = 'GPS Detected';
                        userLocation.source = 'GPS';
                        resolve(true);
                    },
                    (error) => {
                        console.warn('Geolocation Error:', error.code, error.message);
                        reject(error);
                    }, options
                );
            });
        }
        
        async function getIPLocation() {
            try {
                const response = await fetch(IP2LOCATION_URL_BASE);
                const data = await response.json();
                if (response.ok && data.latitude && data.longitude && data.country_code !== 'N/A') {
                    userLocation.lat = parseFloat(data.latitude);
                    userLocation.lon = parseFloat(data.longitude);
                    userLocation.city = data.city_name || 'Unknown City';
                    userLocation.region = data.region_name || 'Unknown Region';
                    userLocation.source = 'IP Fallback';
                    return true;
                }
            } catch (e) { console.warn("IP2Location API call failed.", e); }
            return false;
        }

        async function getUserLocation() {
            const display = document.getElementById('current-location-display');
            display.classList.add('pulse-animation');
            display.innerHTML = 'Detecting location via GPS...';

            let gpsAttempt = null;
            let ipAttempt = null;
            let permissionStatus = null;

            try {
                if (navigator.permissions && navigator.permissions.query) {
                    try {
                        permissionStatus = await navigator.permissions.query({ name: 'geolocation' });
                    } catch (err) {
                        permissionStatus = null;
                    }
                }

                if (permissionStatus && permissionStatus.state === 'granted') {
                    try {
                        await getGPSLocation();
                        updateLocationUI();
                        return;
                    } catch (e) { console.warn('GPS attempt after granted failed', e); }
                }

                ipAttempt = getIPLocation();

                gpsAttempt = (async () => {
                    const attempts = [3000, 5000, 8000];
                    for (const t of attempts) {
                        try {
                            await new Promise((res, rej) => {
                                navigator.geolocation.getCurrentPosition(res, rej, { enableHighAccuracy: true, timeout: t });
                            });
                            await getGPSLocation();
                            return true;
                        } catch (err) {
                            if (err && err.code === 1) {
                                console.warn('User denied geolocation permission.');
                                throw err;
                            }
                            console.warn('GPS retry failed, will retry:', err && err.message ? err.message : err);
                            await new Promise(r => setTimeout(r, 500));
                        }
                    }
                    return false;
                })();

                if (permissionStatus && typeof permissionStatus.addEventListener === 'function') {
                    const onChange = async () => {
                        try {
                            if (permissionStatus.state === 'granted') {
                                console.log('Geolocation permission granted (change event). Retrying GPS.');
                                try {
                                    await getGPSLocation();
                                    updateLocationUI();
                                } catch (e) { console.warn('GPS after permission change failed', e); }
                            }
                        } catch (e) { console.warn('permissionStatus onchange handler error', e); }
                    };
                    try { permissionStatus.addEventListener('change', onChange); } catch (e) { try { permissionStatus.onchange = onChange; } catch(_){} }
                }

                let usedGPS = false;
                try {
                    const winner = await Promise.race([gpsAttempt.catch(() => false), ipAttempt.catch(() => false)]);
                    if (winner === true) {
                        usedGPS = true;
                    } else {
                        const ipOk = await ipAttempt.catch(() => false);
                        if (ipOk) usedGPS = false;
                        else {
                            usedGPS = false;
                        }
                    }
                } catch (e) {
                    console.warn('Race between GPS/IP failed', e);
                }

                if (usedGPS) {
                    updateLocationUI();
                    return;
                }

                const ipOkNow = await ipAttempt.catch(() => false);
                if (ipOkNow) {
                    updateLocationUI();
                    gpsAttempt.then((res) => {
                        if (res) updateLocationUI();
                    }).catch(() => {});
                    return;
                }

                userLocation.source = 'Manual Input Required';
                userLocation.city = 'N/A';
                userLocation.region = 'N/A';
                userLocation.lat = 0;
                userLocation.lon = 0;
                updateLocationUI();

            } catch (e) {
                console.warn('getUserLocation top-level error', e);
                userLocation.source = 'Manual Input Required';
                userLocation.city = 'N/A';
                userLocation.region = 'N/A';
                userLocation.lat = 0; userLocation.lon = 0;
                updateLocationUI();
            }
        }

        document.getElementById('manual-location-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const cityInput = document.getElementById('manual-city-input').value.trim();
            if (cityInput) {
                userLocation.city = cityInput;
                userLocation.region = 'Manual Input';
                userLocation.source = 'Manual';
                if (userLocation.lat === 0 && userLocation.lon === 0) {
                    userLocation.lat = 3.140853; 
                    userLocation.lon = 101.693240;
                }
                updateLocationUI();
            }
        });


        // --- Utility Helpers ---
        function makeJamaiHeaders() {
            const h = { 'Content-Type': 'application/json' };
            // Always use a single Authorization header with Bearer scheme
            if (JAMAI_PAT) h['Authorization'] = 'Bearer ' + JAMAI_PAT;
            // Include both common project-id header casings to maximize compatibility
            if (JAMAI_PROJECT_ID) {
                h['X-PROJECT-ID'] = JAMAI_PROJECT_ID;
                h['X-Project-Id'] = JAMAI_PROJECT_ID;
            }
            return h;
        }

        // Attempt to fetch `pps_knowledge` rows from JamAI as RAG context.
        // Tries several plausible action-table list/query endpoints and returns
        // a concatenated, human-readable text block suitable for prompt inclusion.

        async function fetchPPSKnowledge() {
    const tableApiUrl = window.JAMAI_TABLE_API_URL || (JAMAI_API_URL && JAMAI_PROJECT_ID ? `${JAMAI_API_URL.replace(/\/$/, '').split('/v1')[0].replace(/\/$/, '')}/api/v2/gen_tables/action` : null);
    const headers = makeJamaiHeaders();

    if (!tableApiUrl) return "";

    try {
        const url = `${tableApiUrl}/rows/list`;
        const r = await fetch(url, { headers });
        const data = await r.json();
        if (data && data.rows) {
            return data.rows.map(p => `- ${p.name} | lat:${p.lat} lon:${p.lon} | features: ${p.features} | capacity: ${p.capacity}`).join('\n');
        }
    } catch (e) {
        console.warn("pps_knowledge fetch failed", e);
    }
    return "";
}


        function togglePkpassButton(data) {
            const btn = document.getElementById('email-pkpass-button');
            const statusEl = document.getElementById('pkpass-status');
            
            // Check for minimum required data to create a meaningful pass
            const isReady = data && data.jkmPayload && data.headName && data.icNumber && data.familySize > 0;
            
            if (isReady) {
                btn.disabled = false;
                btn.classList.remove('hidden');
                statusEl.textContent = 'Ready to send JKM Passport to your email for Wallet.';
            } else {
                btn.disabled = true;
                btn.classList.add('hidden');
                statusEl.textContent = '(Save details and ensure Name, IC, and Size are filled to enable Wallet export)';
            }
        }

        // --- Data & UI Update Handlers ---

        window.updateUIAfterDataLoad = (data) => {
            window.familyData = data;
            const form = document.getElementById('family-form');
            const vulnerabilitiesDisplay = document.getElementById('vulnerability-list-display');
            
            if (Object.keys(data).length > 0) {
                ['headName', 'icNumber', 'address', 'familySize'].forEach(key => {
                    const input = form.querySelector(`#${key}`);
                    if (input && data[key] !== undefined) input.value = data[key];
                });
                
                const vulns = data.vulnerabilities?.join('; ') || 'None saved.';
                vulnerabilitiesDisplay.textContent = vulns;

            } else {
                form.reset();
                vulnerabilitiesDisplay.textContent = 'None saved.';
            }

            updateQRCode(data);
            updateRoutingTab(data);
            togglePkpassButton(data);
        };
        
        function updateRoutingTab(data) {
            const currentVulnerabilitiesDiv = document.getElementById('current-vulnerabilities');
            const routingCoords = document.getElementById('routing-coords');

            const vulns = data.vulnerabilities?.join('; ') || 'None reported.';
            currentVulnerabilitiesDiv.innerHTML = `<span class="font-bold text-indigo-700">${vulns}</span>`;
            routingCoords.textContent = `${userLocation.lat.toFixed(4)}, ${userLocation.lon.toFixed(4)} (Source: ${userLocation.source})`;
        }


        // --- Feature 1 & 2: Semantic Decoding & Routing (with RAG and Qwen3-VL) ---
        // PPS data is now stored in 'pps_knowledge' action table for RAG grounding
        // The list below is retained ONLY for displaying the analysis results in the UI.
        
        // SOP Knowledge: Malaysian Flood Mitigation - concise grounding text for RAG (retained for reference)
        const SOP_KNOWLEDGE = `Standard Operating Procedures for Malaysian Flood Mitigation (summary):
    1) Monitor official weather and agensi kerajaan updates; follow evacuation orders immediately.
    2) Prioritise evacuation of vulnerable persons: elderly, bedridden, infants, pregnant women, and persons with disabilities (OKU).
    3) Pets: declare animals at registration; some PPS allow pets in designated areas‚Äîbring carriers and food.
    4) Bring essential documents (ICs), medications, minimal bedding, drinking water, and basic food; label items with head of family name.
    5) Hygiene: bring face masks, soap, hand sanitizer, and maintain distancing where possible.
    6) Sanitation: use provided toilets; report sanitary issues to PPS officer.
    7) Electrical safety: avoid floodwaters, do not use electrical appliances in water; generators must be outdoors with safe ventilation.
    8) Medical emergencies: inform PPS medical teams immediately; register special needs on arrival for priority assistance.
    9) Registration: register at the PPS counter, obtain family token/QR, comply with volunteer instructions.
    10) Communication: keep phones charged, use designated family contact points, and do not re-enter flooded areas until declared safe.`;
        
        document.getElementById('semantic-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (userLocation.source !== 'GPS' && userLocation.source !== 'IP Fallback' && userLocation.source !== 'Manual') {
                alert("Please confirm your location in Step 1 before routing.");
                return;
            }
            
            const semanticInput = document.getElementById('semantic-input').value.trim();
            if (semanticInput) {
                await findOptimalPPS(semanticInput);
                showTab('routing'); // Automatically switch to Routing tab
            }
        });

        async function findOptimalPPS(semanticInput) {
            
            const button = document.getElementById('semantic-submit-button');
            const listDiv = document.getElementById('pps-list');
            const matchDiv = document.getElementById('best-match-display');
            const citationDiv = document.getElementById('jamai-citation');
            const currentVulnerabilitiesDiv = document.getElementById('current-vulnerabilities');
            const statusContentDiv = document.getElementById('status-content');
            const statusCard = document.getElementById('local-status-results-routing');
            
            // 1. Setup UI for Loading
            button.disabled = true; button.classList.add('opacity-50'); button.textContent = '‚ú® Analyzing Situation & Status...';
            listDiv.innerHTML = '<p class="text-gray-500 pulse-animation font-semibold">Calculating PPS suitability...</p>';
            matchDiv.classList.add('hidden'); citationDiv.classList.add('hidden'); 
            currentVulnerabilitiesDiv.innerHTML = 'Analyzing...';
            statusContentDiv.innerHTML = '<p class="text-sm text-gray-500 pulse-animation">Fetching real-time weather and alerts...</p>';
            statusCard.classList.remove('bg-green-100', 'border-green-500', 'bg-red-100', 'border-red-500', 'bg-gray-100');
            statusCard.classList.add('bg-blue-100', 'border-blue-500'); // Temp loading color

            let decodedVulnerabilities = [];

            // --- Step 1: Decode Semantic Intent (LLM Call 1) ---
            try {
                const decodingPrompt = `Analyze the following emergency situation. Extract and list the distinct vulnerabilities, special needs, and key family details relevant to a relief center (PPS). Output ONLY a comma-separated list of structured keywords. Mandatory keywords: Family size (e.g., '5 Pax'). If no other vulnerability is mentioned, only output the 'X Pax' tag. Other keywords: 'Warga Emas/Bedridden', 'Pet/Cat', 'Wheelchair User (OKU)', 'Dietary Restrictions'.
                User Input: "${semanticInput}"`;
                
                const payload1 = { contents: [{ parts: [{ text: decodingPrompt }] }], systemInstruction: { parts: [{ text: "You are a data decoder. Provide only a comma-separated list of standardized tags." }] } };
                const jamaiHeaders = makeJamaiHeaders();
                
                // Exponential backoff logic for retries
                let response1, result1;
                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        response1 = await fetch(LLM_API_URL, { method: 'POST', headers: jamaiHeaders, body: JSON.stringify(payload1) });
                        if (response1.ok) {
                            result1 = await response1.json();
                            break;
                        } else {
                            // If not OK, wait and retry (2s, 4s, 8s)
                            await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                        }
                    } catch (e) {
                        // Network error, wait and retry
                        await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                    }
                }

                if (!result1) throw new Error("LLM Decode failed after retries.");

                const decodedText = result1.candidates?.[0]?.content?.parts?.[0]?.text || "";
                
                decodedVulnerabilities = decodedText.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
                
                if (decodedVulnerabilities.length === 0) { decodedVulnerabilities = ['N/A Pax']; }
                
                window.familyData.vulnerabilities = decodedVulnerabilities; 
                currentVulnerabilitiesDiv.innerHTML = `<span class="font-bold text-indigo-700">${decodedVulnerabilities.join('; ')}</span>`;
                
            } catch (error) {
                console.error("Semantic Decoding Error:", error);
                matchDiv.classList.remove('hidden'); matchDiv.innerHTML = `<p class="text-lg font-bold text-red-600">Decoding Failed</p>`;
                button.disabled = false; button.classList.remove('opacity-50'); button.textContent = '‚ú® Get Safe Route & Local Status'; return;
            }


            // --- Step 2: Intelligent Routing & Status Check (LLM Call 2) ---

            button.textContent = '‚ú® Finalizing Report...';

            const locationString = userLocation.source !== 'Manual Input Required' ? `${userLocation.city}, ${userLocation.region} (Lat: ${userLocation.lat.toFixed(4)}, Lon: ${userLocation.lon.toFixed(4)})` : userLocation.city;
            
            // Status Check 
            const statusPrompt = `Provide a real-time update on the current weather, flood risk, and any active government evacuation orders for the location: ${locationString}. Provide a single, concise paragraph and assess the immediate danger level (Low/Medium/High).`;
            let statusResponseText = "Status check failed.";
            let statusCardClasses = 'bg-gray-100 border-gray-400';

            try {
                const statusPayload = { contents: [{ parts: [{ text: statusPrompt }] }], tools: [{ "google_search": {} }], systemInstruction: { parts: [{ text: "You are an emergency status reporter providing only official, real-time Malaysian weather and alert data." }] } };
                
                let statusResult;
                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        const statusResponse = await fetch(LLM_API_URL, { method: 'POST', headers: makeJamaiHeaders(), body: JSON.stringify(statusPayload) });
                        if (statusResponse.ok) {
                            statusResult = await statusResponse.json();
                            break;
                        } else {
                            await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                        }
                    } catch (e) {
                        await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                    }
                }

                if (statusResult) {
                    statusResponseText = statusResult.candidates?.[0]?.content?.parts?.[0]?.text || statusResponseText;
                }
                
                const isHighDanger = statusResponseText.toLowerCase().includes('high danger') || statusResponseText.toLowerCase().includes('evacuation order');
                statusCardClasses = isHighDanger ? 'bg-red-100 border-red-500' : 'bg-green-100 border-green-500';
                
                statusContentDiv.innerHTML = `<p class="text-sm whitespace-pre-wrap text-gray-800">${statusResponseText}</p>`;

            } catch(e) { console.error("Status Check Error:", e); statusContentDiv.innerHTML = '<p class="text-sm text-red-600 font-bold">Failed to fetch real-time status. Network error.</p>'; }
            
            statusCard.classList.remove('bg-blue-100', 'border-blue-500');
            statusCard.classList.add(...statusCardClasses.split(' '));
            
            // Routing Logic (UPDATED: Rely on JamAI RAG for PPS list)
            const systemPrompt = "You are an emergency management AI. Use the supplied SOP knowledge and the PPS knowledge table (RAG) to ground recommendations. Analyze user vulnerabilities and available PPS to select the single, best-suited center. Provide a concise Chain-of-Thought explaining acceptance/rejection based on user needs and SOPs. Finally, output the name of the BEST MATCH in its own, single line at the end (e.g., BEST MATCH: PPS North (Sekolah)).";


            const userQuery = `User Needs: ${decodedVulnerabilities.join('; ')}. Location: ${locationString}. SOP: ${SOP_KNOWLEDGE}\n\nPPS_KNOWLEDGE:\n${ppsKnowledgeText}`;
            
            let bestMatchName = null;
            let fullAnalysisText = "";
            listDiv.innerHTML = ''; 

            try {
                const payload2 = { contents: [{ parts: [{ text: userQuery }] }], systemInstruction: { parts: [{ text: systemPrompt }] } };
                
                let result2;
                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        const response2 = await fetch(LLM_API_URL, { method: 'POST', headers: makeJamaiHeaders(), body: JSON.stringify(payload2) });
                        if (response2.ok) {
                            result2 = await response2.json();
                            break;
                        } else {
                            await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                        }
                    } catch (e) {
                        await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                    }
                }
                
                if (!result2) throw new Error("LLM Routing failed after retries.");

                fullAnalysisText = result2.candidates?.[0]?.content?.parts?.[0]?.text || '';

                const lines = fullAnalysisText.trim().split('\n');
                const lastLine = lines.find(line => line.toUpperCase().startsWith('BEST MATCH:'));
                if (lastLine) { bestMatchName = lastLine.replace('BEST MATCH:', '').trim(); }

                // Display analysis based on the local PPS list (for UI consistency)
                const analysisSections = fullAnalysisText.split('Analyze PPS');

                PPS_DATA.forEach((pps) => {
                    const section = analysisSections.find(s => s.includes(pps.name));
                    let status = "SUITABLE";
                    let color = "bg-yellow-100 border-yellow-500";
                    let icon = '‚ö†Ô∏è';
                    
                    if (pps.name === bestMatchName) {
                        status = "BEST MATCH"; color = "bg-green-100 border-green-500"; icon = '‚úÖ';
                    } else if (section && (section.includes('Rejection') || section.includes('Rejected'))) {
                        status = "NOT SUITABLE"; color = "bg-red-100 border-red-500"; icon = '‚ùå';
                    }

                    const analysisDetail = section ? section.substring(section.indexOf(':') + 1).trim() : "AI analysis unavailable.";
                    
                    listDiv.innerHTML += `
                        <div class="card p-4 border-2 ${color}">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-lg font-bold">${icon} ${pps.name}</span>
                                <span class="text-sm font-semibold text-gray-700">${pps.distance_km}km away</span>
                            </div>
                            <p class="text-xs text-gray-600 mb-2">Features: ${pps.features}</p>
                            <div class="text-sm text-gray-800">
                                <span class="font-bold">${status}:</span> 
                                ${analysisDetail.replace(/\n/g, '<br>')}
                            </div>
                        </div>
                    `;
                });
                
                if (bestMatchName) {
                    matchDiv.classList.remove('hidden');
                    matchDiv.innerHTML = `
                        <p class="text-2xl font-extrabold text-green-700">Best Match Found!</p>
                        <p class="text-4xl font-extrabold text-indigo-700 my-2">${bestMatchName}</p>
                        <p class="text-lg text-gray-700">Proceed to the **QR Passport** tab to prepare your documents.</p>
                    `;
                }

                citationDiv.classList.remove('hidden');

            } catch (error) {
                console.error("JamAI Routing Error:", error);
                matchDiv.classList.remove('hidden'); matchDiv.innerHTML = `<p class="text-lg font-bold text-red-600">Routing Failed</p>`;
                listDiv.innerHTML = '';
            } finally {
                button.disabled = false; button.classList.remove('opacity-50'); button.textContent = '‚ú® Get Safe Route & Local Status';
            }
        }
        
        // --- Feature 3: QR Passport and PKPASS (Simulated) ---

        document.getElementById('family-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const form = e.target;
            const vulnerabilities = window.familyData.vulnerabilities || []; 

            const formData = {
                headName: form.headName.value, icNumber: form.icNumber.value, address: form.address.value,
                familySize: parseInt(form.familySize.value), vulnerabilities: vulnerabilities,
            };

            formData.jkmPayload = generateJKMQRPayload(formData);

            const statusEl = document.getElementById('save-status');
            const success = await window.saveFamilyData(formData);

            if (success) {
                statusEl.textContent = "Data saved successfully! Your QR Passport is ready.";
                statusEl.classList.remove('hidden', 'bg-red-100', 'text-red-700');
                statusEl.classList.add('bg-green-100', 'text-green-700');
                togglePkpassButton(formData);
            } else {
                statusEl.textContent = "Error saving data. Check console.";
                statusEl.classList.remove('hidden', 'bg-green-100', 'text-green-700');
                statusEl.classList.add('bg-red-100', 'text-red-700');
            }
            setTimeout(() => statusEl.classList.add('hidden'), 5000);
        });

        function generateJKMQRPayload(data) {
            const payload = {
                schema: "JKM_PPS_v1.0", timestamp: new Date().toISOString(), ref_id: window.userId.substring(0,12), 
                nama_ketua: data.headName || 'N/A', no_ic: data.icNumber || 'N/A', alamat: data.address || 'N/A', 
                jumlah_ahli: data.familySize || 0, keperluan_khas: data.vulnerabilities || []
            };
            return JSON.stringify(payload, null, 0);
        }

        function updateQRCode(data = window.familyData) {
            const statusEl = document.getElementById('qr-status');
            const previewEl = document.getElementById('jkm-payload-preview');
            const copyButton = document.getElementById('copy-payload-button');
            const canvas = document.getElementById('qr-canvas');

            if (data && data.jkmPayload) {
                statusEl.textContent = "QR Code Generated. Ready to scan.";
                statusEl.classList.remove('text-red-500'); statusEl.classList.add('text-green-600');
                copyButton.classList.remove('hidden');
                previewEl.textContent = JSON.stringify(JSON.parse(data.jkmPayload), null, 2); // Prettier JSON in preview

                QRCode.toCanvas(canvas, data.jkmPayload, {
                    errorCorrectionLevel: 'H', width: 300, margin: 1, color: { dark: '#1f2937', light: '#ffffff' }
                }, function (error) { if (error) console.error(error); });
            } else {
                statusEl.textContent = "No family data saved yet. Please complete the form above.";
                statusEl.classList.add('text-red-500'); statusEl.classList.remove('text-green-600');
                previewEl.textContent = 'Awaiting data...';
                copyButton.classList.add('hidden');
                const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        document.getElementById('email-pkpass-button').addEventListener('click', async () => {
            if (!window.familyData || !window.familyData.jkmPayload) return;

            const email = prompt("Enter your email address to receive the Wallet Pass (.pkpass):\n\nNOTE: This is a simulation. Generating a PKPASS requires a secure server.");
            if (!email) return;

            const btn = document.getElementById('email-pkpass-button');
            const pkpassStatusEl = document.getElementById('pkpass-status');
            const originalText = btn.textContent;
            
            btn.disabled = true;
            btn.textContent = 'Sending... Please Wait.';
            pkpassStatusEl.textContent = `Requesting Wallet Pass generation for ${email}...`;

            try {
                // Simulate network latency and server processing time
                await new Promise(resolve => setTimeout(resolve, 2500)); 

                pkpassStatusEl.innerHTML = `‚úÖ Success! A server-generated <b>Wallet Pass (.pkpass)</b> has been hypothetically emailed to <b>${email}</b>.`;
                btn.textContent = 'Email Sent! ‚úÖ';

            } catch (e) {
                pkpassStatusEl.textContent = '‚ùå Generation Failed. Wallet Pass requires a secure server backend.';
                btn.textContent = 'Email Failed ‚ùå';
            } finally {
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 5000);
            }
        });

        // --- Feature 4: Rumour Killer (Grounded Q&A) ---

        document.getElementById('rumour-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const inputEl = document.getElementById('rumour-input');
            const query = inputEl.value.trim();
            inputEl.value = '';
            if (!query) return;
            await rumourKillerChat(query);
        });

        async function rumourKillerChat(query) {
            const chatWindow = document.getElementById('chat-window');
            const submitButton = document.getElementById('rumour-submit-button');
            
            chatWindow.innerHTML += `<div class="user-message">${query}</div>`;
            chatWindow.scrollTop = chatWindow.scrollHeight;

            const loadingHtml = `<div id="ai-loading" class="ai-message"><span class="pulse-animation font-semibold">Thinking...</span></div>`;
            chatWindow.innerHTML += loadingHtml;
            chatWindow.scrollTop = chatWindow.scrollHeight;

            submitButton.disabled = true; submitButton.classList.add('opacity-50');
            
            try {
                const systemPrompt = "You are the 'Rumour Killer' AI, a dedicated disaster management bot. Use up-to-date, real-time search results to answer questions about disaster status, SOPs, and verify rumors. Provide a clear, factual answer based on the search results. If you cannot verify the information, state it politely.";

                const payload = { contents: [{ parts: [{ text: query }] }], tools: [{ "google_search": {} }], systemInstruction: { parts: [{ text: systemPrompt }] } };

                let result;
                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        const response = await fetch(LLM_API_URL, { method: 'POST', headers: makeJamaiHeaders(), body: JSON.stringify(payload) });
                        if (response.ok) {
                            result = await response.json();
                            break;
                        } else {
                            await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                        }
                    } catch (e) {
                        await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                    }
                }
                
                if (!result) throw new Error("LLM Chat failed after retries.");

                const candidate = result.candidates?.[0];
                let text = "Sorry, I couldn't get a response from the network.";
                let sources = [];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    text = candidate.content.parts[0].text;
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({ uri: attribution.web?.uri, title: attribution.web?.title }))
                            .filter(source => source.uri && source.title);
                    }
                }
                
                let sourceHtml = '';
                if (sources.length > 0) {
                    sourceHtml = '<div class="mt-2 pt-2 border-t border-gray-300 text-xs text-gray-600 font-medium">Sources:</div>';
                    sources.forEach((source, index) => {
                        sourceHtml += `<p class="text-xs text-gray-500 hover:text-indigo-500"><a href="${source.uri}" target="_blank" rel="noopener noreferrer">${index + 1}. ${source.title}</a></p>`;
                    });
                }
                
                document.getElementById('ai-loading')?.remove();
                
                chatWindow.innerHTML += `<div class="ai-message"><p class="text-sm whitespace-pre-wrap">${text}</p>${sourceHtml}</div>`;
            } catch (error) {
                console.error("JamAI Rumour Killer Error:", error);
                document.getElementById('ai-loading')?.remove();
                chatWindow.innerHTML += `<div class="ai-message bg-red-100 text-red-700 border-red-300"><p class="text-sm font-bold">Network error or API failure.</p></div>`;
            } finally {
                submitButton.disabled = false; submitButton.classList.remove('opacity-50');
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }
        }

        // --- JamAI Table Upload Helpers (SOP persistence as Action/Table) ---
        async function uploadSOPToJamAITable() {
            const statusEl = document.getElementById('upload-sop-status');
            statusEl.textContent = 'Preparing upload...';

            // Determine endpoint: use the explicit table URL if provided, otherwise derive from the API URL.
            const tableApiUrl = window.JAMAI_TABLE_API_URL || (JAMAI_API_URL && JAMAI_PROJECT_ID ? `${JAMAI_API_URL.replace(/\/$/, '').split('/v1')[0].replace(/\/$/, '')}/api/v2/gen_tables/action/rows/add` : null);

            if (!tableApiUrl) {
                statusEl.textContent = 'Set window.JAMAI_TABLE_API_URL or JAMAI_API_URL+PROJECT_ID.';
                return { ok: false, error: 'Missing table API URL' };
            }

            if (!JAMAI_PAT) {
                statusEl.textContent = 'Missing JAMAI_PAT.';
                return { ok: false, error: 'Missing PAT' };
            }

            // Build payload for Add Rows API 
            const payload = {
                table_id: 'emergency_routing',
                data: [
                    {
                        action: 'sop_upload',
                        title: 'Malaysian Flood SOP (summary)',
                        text: SOP_KNOWLEDGE,
                        source: 'safe-route-ui',
                        created_at: new Date().toISOString()
                    }
                ],
                stream: false,
                concurrent: false
            };

            let result;
            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    statusEl.textContent = 'Uploading SOP to JamAI...';
                    const res = await fetch(tableApiUrl, {
                        method: 'POST',
                        headers: makeJamaiHeaders(),
                        body: JSON.stringify(payload)
                    });

                    if (res.ok) {
                        result = { ok: true, status: res.status };
                        break;
                    } else {
                        await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                    }
                } catch (err) {
                    await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                }
            }


            if (result && result.ok) {
                statusEl.textContent = 'SOP uploaded successfully.';
                return result;
            } else {
                statusEl.textContent = `Upload failed (network/API error).`;
                console.error('SOP upload failed after retries.');
                return { ok: false, error: 'Failed after retries' };
            }
        }

        // Convenience: run test and display result in UI (invoked by Upload SOP button)
        async function runSOPTest() {
            const btn = document.getElementById('upload-sop-button');
            const statusEl = document.getElementById('upload-sop-status');
            btn.disabled = true; btn.textContent = 'Testing...'; statusEl.textContent = '';

            try {
                // Attempt upload and show result
                const result = await uploadSOPToJamAITable();
                if (result.ok) {
                    statusEl.textContent = 'SOP upload success (check console for details)';
                } else {
                    statusEl.textContent = `Upload failed: ${result.error || 'Check console'}`;
                }
            } finally {
                btn.disabled = false; btn.textContent = 'Upload SOP to JamAI (Test)';
            }
        }

        // Post emergency routing rows to the JamAI table using the action-table schema
        async function postEmergencyRoutingRows(decodeRow, routeRow) {
            const statusEl = document.getElementById('save-routing-status');
            statusEl.textContent = 'Preparing to save routing...';

            // Determine endpoint: use the explicit table URL if provided
            const tableApiUrl = window.JAMAI_TABLE_API_URL || (JAMAI_API_URL && JAMAI_PROJECT_ID ? `${JAMAI_API_URL.replace(/\/$/, '').split('/v1')[0].replace(/\/$/, '')}/api/v2/gen_tables/action/rows/add` : null);

            if (!tableApiUrl) {
                statusEl.textContent = 'Configure JAMAI_TABLE_API_URL or JAMAI_API_URL+PROJECT_ID.';
                return { ok: false, error: 'missing_table_url' };
            }
            if (!JAMAI_PAT) return { ok: false, error: 'Missing PAT' };
            
            const payload = { 
                table_id: 'emergency_routing', 
                data: [decodeRow, routeRow], 
                stream: false, 
                concurrent: false 
            };
            
            let result;
            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    statusEl.textContent = 'Saving rows to JamAI...';
                    const res = await fetch(tableApiUrl, { method: 'POST', headers: makeJamaiHeaders(), body: JSON.stringify(payload) });
                    if (res.ok) {
                        result = { ok: true, status: res.status };
                        break;
                    } else {
                        await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                    }
                } catch (err) {
                    await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
                }
            }

            if (result && result.ok) {
                    statusEl.textContent = 'Saved routing rows.';
                    // Try to parse completion results from Add-Rows response and update UI/state
                    try {
                        const bodyJson = (typeof result.body === 'string') ? JSON.parse(result.body) : (result.body || null);
                        if (bodyJson) parseAddRowsCompletion(bodyJson);
                    } catch (e) { console.warn('Could not parse Add-Rows response body for completions', e); }
                    return result;
            } else {
                statusEl.textContent = `Save failed (network/API error).`;
                console.error('postEmergencyRoutingRows failed after retries.');
                return { ok: false, error: 'Failed after retries' };
            }
        }

        // Parse Add-Rows completion response and update UI/state
        function parseAddRowsCompletion(addRowsJson) {
            try {
                const rows = addRowsJson.rows || [];
                if (!rows.length) return;
                // We expect either one row containing multiple completion columns, or multiple rows
                const row = rows[0];
                const columns = row.columns || {};

                // Extract decoded_tags completion if present
                if (columns.decoded_tags) {
                    const dec = columns.decoded_tags;
                    const decodedText = dec?.choices?.[0]?.message?.content || dec?.choices?.[0]?.text || dec?.content?.parts?.[0]?.text || '';
                    if (decodedText) {
                        const tags = decodedText.split(',').map(t => t.trim()).filter(Boolean);
                        window.familyData = window.familyData || {};
                        window.familyData.vulnerabilities = tags.length ? tags : (window.familyData.vulnerabilities || ['N/A Pax']);
                        if (window.updateUIAfterDataLoad) window.updateUIAfterDataLoad(window.familyData);
                        console.log('Parsed decoded_tags from Add-Rows:', tags);
                    }
                }

                // Extract routing/completion analysis if present
                if (columns.route_optimal_pps) {
                    const rt = columns.route_optimal_pps;
                    const routeText = rt?.choices?.[0]?.message?.content || rt?.choices?.[0]?.text || rt?.content?.parts?.[0]?.text || '';
                    if (routeText) {
                        // Look for BEST MATCH line
                        const lines = routeText.split('\n').map(l => l.trim()).filter(Boolean);
                        const bestLine = lines.reverse().find(l => l.toUpperCase().startsWith('BEST MATCH:'));
                        if (bestLine) {
                            const best = bestLine.replace(/BEST MATCH:/i, '').trim();
                            const matchDiv = document.getElementById('best-match-display');
                            matchDiv.classList.remove('hidden');
                            matchDiv.innerHTML = `\n                                <p class="text-2xl font-extrabold text-green-700">Best Match Found! (from JamAI)</p>\n                                <p class="text-4xl font-extrabold text-indigo-700 my-2">${best}</p>\n                                <p class="text-lg text-gray-700">Proceed to the **QR Passport** tab to prepare your documents.</p>\n                            `;
                            console.log('Parsed BEST MATCH from Add-Rows:', best);
                        }
                    }
                }
            } catch (e) { console.warn('parseAddRowsCompletion error', e); }
        }

        // Called by the "Save routing to JamAI table" button.
async function saveRoutingToJamAI() {
    const url = window.JAMAI_TABLE_API_URL || JAMAI_API_URL.replace(/\/v1.*$/, '') + '/api/v2/gen_tables/action/rows/add';
    const payload = {
        table_id: "emergency_routing",
        data: [
            {
                id: "row-" + Date.now(),
                input: document.getElementById('semantic-input').value,
                created_at: new Date().toISOString()
            }
        ],
        stream: true,   // ‚úÖ stream completions back
        concurrent: false
    };

    try {
        const r = await fetch(url, {
            method: 'POST',
            headers: makeJamaiHeaders(),
            body: JSON.stringify(payload)
        });
        const data = await r.json();
        document.getElementById('save-routing-status').textContent = "Saved!";

        if (data.rows && data.rows[0]) {
            const row = data.rows[0];
            // Show decoded_tags
            document.getElementById('current-vulnerabilities').textContent = row.decoded_tags || "N/A";
            // Show analysis_text
            document.getElementById('analysis-display').classList.remove('hidden');
            document.getElementById('analysis-display').textContent = row.analysis_text || "N/A";
            // Show selected_pps
            document.getElementById('best-match-display').classList.remove('hidden');
            document.getElementById('best-match-display').textContent = row.selected_pps || "N/A";
            // Show citation
            document.getElementById('jamai-citation').classList.remove('hidden');
        }
    } catch (e) {
        document.getElementById('save-routing-status').textContent = "Error saving.";
        console.error(e);
    }
}


        // --- Tab Management ---
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.tab-button').forEach(el => el.classList.remove('active'));

            document.getElementById(tabId).classList.remove('hidden');
            document.getElementById(`tab-${tabId}`).classList.add('active');

            if (tabId === 'qr-passport') updateQRCode();
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            showTab('situation');
            getUserLocation();
            window.loadFamilyData();
        });
    </script>
</body>
</html>